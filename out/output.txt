=== index.html ===
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="quiz-container">
        <h1>QuizeSCH</h1>
        <div id="question-container"></div>
        <div id="navigation-controls">
             <button id="prev-btn" disabled>Previous</button>
             <button id="evaluate-btn">Evaluate Question</button>
             <button id="next-btn">Next</button>
             <button id="submit-btn" style="display: none;">Submit Quiz</button>
			 <button id="reset-btn">Clear</button>
			 <button id="shuffle-toggle-btn">Shuffle Questions</button> </div>
        <div id="result-container" style="display: none;">
            <h2>Your Score:</h2>
            <p id="score"></p>
        </div>
        <div id="warning-message" style="border: 2px solid #f39c12; background-color: #fff3cd; padding: 15px; margin-top: 50px; margin-bottom: 20px; border-radius: 8px; font-size: 12px">
			<strong style="color: #d35400;">‚ö†Ô∏è Warning:</strong> This quiz is still under construction. Data is being manually extracted from the provided PDFs and turned into JSONs using multimodal LLM prompting. This means there definitely wil be broken questions along the way.<br><br>
				üõ†Ô∏è Feel free to contribute to the project on GitHub by extending codebase or fixing questions:
			<a href="https://github.com/forianzsiga/quizesch" target="_blank">https://github.com/forianzsiga/quizesch</a><br><br>
				üöÄ Upcoming features:
			<ul style="margin-top: 10px;">
				<li>Making progression persistent in browser</li>
				<li>Server-side generation of new questions via OpenAI API based on past questions + merged presentation notes submitted as a PDF</li>
			</ul>
		</div>
        <div id="attribution-notice">
            Made with <3 by Zsigmond Forian-Szabo <br> Project is under MIT License
        </div>
    </div>
    <div id="progress-panel"></div>
    <div id="quiz-list-container">
			<h2>Available Quizzes</h2>
			<ul id="quiz-list"></ul>
		</div>
        <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
        <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
        <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
        <script type="module" src="js/main.js"></script> </body>
</body>
</html>
```

=== style.css ===
```
body {
    font-family: sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background-color: #f4f4f4;
    margin: 0; /* Add this to prevent potential scrollbars */
}

#quiz-container {
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    width: 80%;
    max-width: 600px;
    position: relative; /* Needed for absolute positioning of children */
    padding-bottom: 45px; /* Add padding to prevent overlap with the notice */
}

#question-container {
    margin-bottom: 20px;
    padding-bottom: 10px; /* Reduced slightly for vote UI */
    border-bottom: 1px solid #eee;
}

h1, h2 {
    text-align: center;
    color: #333;
}

h3 {
    margin-bottom: 10px;
    color: #555;
}

label {
    display: block; /* Make labels stack */
    margin-bottom: 8px;
    cursor: pointer;
}

.input-wrapper {
    display: inline-block;
    vertical-align: middle; /* Adjust as needed: baseline, bottom, top */
    margin: 0 2px; /* Optional: Add tiny space around the wrapper */
}

.input-wrapper input[type="text"] {
    width: 120px;          /* Give it a fixed width appropriate for blanks */
    display: inline-block; /* Ensure it flows inline */
    vertical-align: middle;/* Align input within the wrapper/text */
    margin: 0;             /* Remove vertical margins */
    padding: 4px 6px;      /* Optionally reduce padding slightly */
    margin-top: 0;
    margin-bottom: 0;
}

li.evaluation-correct {
    background-color: #e0ffe0;
    padding: 3px 6px;
    margin-bottom: 4px;
    border-radius: 4px;
    border-left: 3px solid green;
}

li.evaluation-incorrect {
    background-color: #ffe0e0;
    padding: 3px 6px;
    margin-bottom: 4px;
    border-radius: 4px;
    border-left: 3px solid red;
}

li.evaluation-missed {
    background-color: #fff8e0;
    padding: 3px 6px;
    margin-bottom: 4px;
    border-radius: 4px;
    border-left: 3px solid orange;
}

.input-wrapper .feedback-correct { color: green; }
.input-wrapper .feedback-incorrect { color: red; }
.input-wrapper .feedback-missed { color: orange; }

.input-wrapper input.evaluation-correct {
    border: 1px solid green;
    background-color: #e0ffe0;
}
.input-wrapper input.evaluation-incorrect {
    border: 1px solid red;
    background-color: #ffe0e0;
}
.input-wrapper input.evaluation-missed {
    border: 1px solid orange;
    background-color: #fff8e0;
}

.input-wrapper .inline-feedback {
    display: block;
    font-size: 0.8em;
    margin-top: 2px;
    min-height: 1em;
}


input[type="checkbox"], input[type="radio"] {
    margin-right: 5px;
}

button {
    padding: 10px 15px;
    margin: 5px;
    border: none;
    border-radius: 4px;
    background-color: #007bff;
    color: white;
    cursor: pointer;
    font-size: 1em;
}

button:disabled {
    background-color: #ccc;
    cursor: not-allowed;
}

button:hover:not(:disabled) {
    background-color: #0056b3;
}

/* Basic Drag and Drop Styling */
.drop-target {
    display: inline-block;
    border: 1px dashed #ccc;
    padding: 5px 10px;
    margin: 0 5px;
    min-width: 80px;
    min-height: 20px;
    text-align: center;
    vertical-align: middle;
    background-color: #f0f0f0; /* Slightly different from input wrapper */
}

.draggable {
    display: inline-block;
    border: 1px solid #aaa;
    padding: 5px 10px;
    margin: 5px;
    cursor: grab;
    background-color: #f9f9f9;
}
.draggable:active { cursor: grabbing; }

.drag-options-container { /* Added container for drag options heading */
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px solid #eee;
}
#drag-options { /* The actual div holding draggables */
    /* No specific styles needed here unless you want to constrain it */
}


.highlight-drop {
    background-color: #e0ffe0;
}

#attribution-notice {
    position: absolute;
    bottom: 10px;
    right: 15px;
    font-size: 0.75em;
    color: #CCC;
    text-align: right;
}

/* --- Quiz List Styling --- */
#quiz-list-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 40px;
}

#quiz-list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 24px;
    padding: 0;
    margin: 30px 0 0 0;
    width: 100%;
    max-width: 700px;
    list-style: none;
}

.quiz-card {
    background: #f9f9ff;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.07);
    padding: 28px 18px 18px 18px;
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: box-shadow 0.2s, transform 0.2s;
    cursor: pointer;
    border: 1.5px solid #e0e0e0;
    position: relative;
}
.quiz-card:hover {
    box-shadow: 0 6px 18px rgba(0,123,255,0.13);
    transform: translateY(-3px) scale(1.03);
    border-color: #007bff;
}
.quiz-card .quiz-icon {
    font-size: 2.2em;
    margin-bottom: 10px;
    color: #007bff;
}
.quiz-card .quiz-title {
    font-weight: 600;
    font-size: 1.1em;
    color: #222;
    margin-bottom: 4px;
    text-align: center;
}
.quiz-card .quiz-filename {
    font-size: 0.85em;
    color: #888;
    margin-bottom: 0;
    text-align: center;
}

#quiz-list li {
    background: none;
    border: none;
    box-shadow: none;
    padding: 0;
    margin: 0;
}

.unsupervised-indicator, .supervised-indicator, .llm-indicator, .partial-indicator {
  display: inline-block;
  border-radius: 16px;
  padding: 2px 10px 2px 8px;
  font-size: 0.9em; /* slightly smaller */
  margin-left: 8px; /* slightly smaller */
  vertical-align: middle;
  font-weight: 500;
  cursor: help;
  user-select: none;
}
.unsupervised-indicator { background: #ffeaea; color: #b30000; border: 1px solid #ffb3b3; }
.supervised-indicator { background: #eaffea; color: #217a21; border: 1px solid #a6e6a6; }
.llm-indicator { background: #eaf3ff; color: #1761a6; border: 1px solid #8ec6ff; }
.partial-indicator { background: #fff8e0; color: #d35400; border: 1px solid #f39c12; }


#quiz-list a, #quiz-list a *, #quiz-list a::after, #quiz-list a::before, #quiz-list a *::after, #quiz-list a *::before {
    text-decoration: none !important;
    color: inherit !important;
}

/* Progress Panel Dot Styles */
.progress-dot {
    display: inline-block;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    margin-right: 8px;
    vertical-align: middle;
    border: 1px solid #999;
}
.dot-neutral { background-color: #bbb; }
.dot-correct { background-color: #27ae60; border-color: #1e8449; }
.dot-incorrect { background-color: #e74c3c; border-color: #c0392b; }
.dot-answered { background-color: #3498db; border-color: #2980b9; }

/* Voting UI Styles */
.vote-ui-container {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #eee;
    font-size: 0.9em;
    display: flex;
    align-items: center;
    flex-wrap: wrap; /* Allow wrapping on small screens */
}

.vote-score-text {
    margin-right: 10px;
    color: #333;
    flex-shrink: 0; /* Prevent text from shrinking too much */
}

.vote-btn {
    padding: 5px 10px;
    margin-left: 5px;
    margin-bottom: 5px; /* For wrapping */
    cursor: pointer;
    border: 1px solid #ccc;
    background-color: #f9f9f9;
    border-radius: 4px;
    font-size: 0.9em; /* Match container */
    color: #333;
}
.vote-btn:hover {
    background-color: #e9e9e9;
}
.vote-btn.selected {
    font-weight: bold;
    border-width: 2px;
}
.vote-btn.trust.selected {
    border-color: green;
    background-color: #e6ffe6;
}
.vote-btn.distrust.selected {
    border-color: red;
    background-color: #ffe6e6;
}

/* Vote UI Styles */
.vote-ui-container {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #eee;
    font-size: 0.9em;
    display: flex;
    align-items: center;
    flex-wrap: wrap; /* Allow wrapping on small screens */
}

.vote-score-text {
    margin-right: 10px;
    color: #333;
    flex-shrink: 0; /* Prevent text from shrinking too much */
}

.vote-btn {
    padding: 5px 10px;
    margin-left: 5px;
    margin-bottom: 5px; /* For wrapping */
    cursor: pointer;
    border: 1px solid #ccc;
    background-color: #f9f9f9;
    border-radius: 4px;
    font-size: 0.9em; /* Match container */
    color: #333;
}
.vote-btn:hover {
    background-color: #e9e9e9;
}
.vote-btn.selected {
    font-weight: bold;
    border-width: 2px;
}
.vote-btn.trust.selected {
    border-color: green;
    background-color: #e6ffe6;
}
.vote-btn.distrust.selected {
    border-color: red;
    background-color: #ffe6e6;
}

.vote-verification-info {
    font-size: 0.8em; /* Relative to parent .vote-ui-container's 0.9em, so ~0.72em of base */
    color: #777;     /* Medium gray for readability */
    margin-top: 8px;  /* Space above it */
    width: 100%;      /* Ensure it takes full width and wraps to new line */
    text-align: left; /* Align text to the left */
    line-height: 1.3; /* Improve readability for multi-line text */
}
```

=== apiService.js ===
```
// js/apiService.js
export async function fetchQuizList(endpoint) {
    const response = await fetch(endpoint);
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status} fetching manifest.`);
    }
    return await response.json();
}

export async function fetchQuizData(filePath) {
    const response = await fetch(filePath);
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status} loading ${filePath}`);
    }
    return await response.json();
}

// Example for supervision info - can be combined with fetchQuizData or separate
export async function fetchQuizSupervisionInfo(filePath) {
    const response = await fetch(filePath); // Or get it from already fetched data
    if (!response.ok) {
        throw new Error(`HTTP error fetching supervision info! status: ${response.status}`);
    }
    const quizData = await response.json();
    let total = quizData.length;
    let supervised = 0, generated = 0, unsupervised = 0;
    quizData.forEach(q => {
        if (typeof q.supervised === 'string') {
            const s = q.supervised.trim().toLowerCase();
            if (s === 'yes') supervised++;
            else if (s === 'generated') generated++;
            else unsupervised++;
        } else {
            unsupervised++;
        }
    });
    return { total, supervised, generated, unsupervised };
}
```

=== config.js ===
```
// js/config.js
let dataDir = '/data/';
if (window.location.hostname.includes("github.io")) {
    dataDir = "/quizesch" + dataDir;
    console.log("github pages detected");
}
export const DATA_DIRECTORY = dataDir.replace(/\/+$/, ''); // Normalize
export const QUIZ_MANIFEST_ENDPOINT = 'data/quiz-manifest.json';
export const STORAGE_KEY = 'quizesch_state_v2'; // Increment version if structure changes
```

=== firebaseService.js ===
```
// js/firebaseService.js
// Use Firebase via CDN scripts in index.html, not ES module imports
// Assumes the following scripts are included in your HTML:
// <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
// <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
// <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

const firebaseConfig = {
  apiKey: "AIzaSyB90aBQyZNgzy6unaosThIC7SUom4wnkXw", // Ensure this is your actual, correct API key
  authDomain: "quizesch.firebaseapp.com",
  projectId: "quizesch",
  storageBucket: "quizesch.firebasestorage.app",
  messagingSenderId: "915027658046",
  appId: "1:915027658046:web:26652b9fd0cc19e219586f"
};

const app = firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
const auth = firebase.auth();

let currentFirebaseUser = null;

auth.onAuthStateChanged((user) => {
    if (user) {
        currentFirebaseUser = user;
        console.log("Firebase: Anonymous user signed in:", user.uid);
    } else {
        currentFirebaseUser = null;
        auth.signInAnonymously().catch((error) => {
            console.error("Firebase: Anonymous sign-in error", error);
        });
    }
});

function getFirestoreQuestionId(quizFileName, questionIndex) {
    const safeQuizFileName = quizFileName.replace('.json', '').replace(/[^a-zA-Z0-9_-]/g, '_');
    return `${safeQuizFileName}_q_${questionIndex}`;
}

// Use export here
export async function recordVote(quizFileName, questionIndex, voteType) {
    if (!currentFirebaseUser) {
        alert("Authentication pending. Please try again in a moment.");
        console.warn("Attempted to vote without firebase user.");
        return null;
    }

    const firestoreQuestionId = getFirestoreQuestionId(quizFileName, questionIndex);
    const questionVoteRef = db.collection("questionTrustVotes").doc(firestoreQuestionId);
    const userVoteRecordRef = db.collection(`userVotes/${currentFirebaseUser.uid}/questionVotes`).doc(firestoreQuestionId);

    try {
        return await db.runTransaction(async (transaction) => {
            const questionVoteSnap = await transaction.get(questionVoteRef);
            const userVoteSnap = await transaction.get(userVoteRecordRef);

            let positiveVotes = 0;
            let totalVotes = 0;
            let previousUserVoteType = null;

            if (questionVoteSnap.exists) {
                positiveVotes = questionVoteSnap.data().positiveVotes || 0;
                totalVotes = questionVoteSnap.data().totalVotes || 0;
            }

            if (userVoteSnap.exists) {
                previousUserVoteType = userVoteSnap.data().voteType;
            }

            if (previousUserVoteType === voteType) {
                console.log("User clicked the same vote button again. No change.");
                return {
                    positiveVotes,
                    totalVotes,
                    userVoted: previousUserVoteType,
                    score: totalVotes > 0 ? parseFloat(((positiveVotes / totalVotes) * 100).toFixed(1)) : 0
                };
            }

            // Adjust votes based on previous vote
            if (previousUserVoteType) { // User is changing their vote
                if (previousUserVoteType === 'trust') positiveVotes--;
                // totalVotes remains the same as it's a change, not a new vote
            } else { // User is casting a new vote
                totalVotes++;
            }

            // Apply current vote
            if (voteType === 'trust') {
                positiveVotes++;
            }
            // If voteType is 'distrust', positiveVotes isn't incremented.

            transaction.set(questionVoteRef, {
                positiveVotes: Math.max(0, positiveVotes), // Ensure non-negative
                totalVotes: Math.max(0, totalVotes),     // Ensure non-negative
                quizFile: quizFileName,
                qIndex: questionIndex,
                lastVoteAt: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true });

            transaction.set(userVoteRecordRef, {
                voteType: voteType,
                votedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            const newScore = totalVotes > 0 ? parseFloat(((positiveVotes / totalVotes) * 100).toFixed(1)) : 0;

            return {
                positiveVotes,
                totalVotes,
                userVoted: voteType,
                score: newScore
            };
        });
    } catch (error) {
        console.error("Firebase: Vote transaction failed: ", error);
        alert("Failed to record vote. Please check your connection and try again.");
        return null;
    }
}

// Use export here
export async function getQuestionVoteData(quizFileName, questionIndex) {
    const firestoreQuestionId = getFirestoreQuestionId(quizFileName, questionIndex);
    const questionVoteRef = db.collection("questionTrustVotes").doc(firestoreQuestionId);
    let userVoteType = null;

    if (currentFirebaseUser) {
        const userVoteRecordRef = db.collection(`userVotes/${currentFirebaseUser.uid}/questionVotes`).doc(firestoreQuestionId);
        try {
            const userVoteSnap = await userVoteRecordRef.get();
            if (userVoteSnap.exists) {
                userVoteType = userVoteSnap.data().voteType;
            }
        } catch (e) {
            console.warn("Firebase: Could not get user's vote record", e);
            // Continue, userVoteType will remain null
        }
    } else {
        // console.log("getQuestionVoteData: No currentFirebaseUser, cannot fetch user's specific vote.");
        // This is not necessarily an error if called before auth completes, 
        // but it means user-specific vote info won't be available.
    }

    try {
        const docSnap = await questionVoteRef.get();
        if (docSnap.exists) {
            const data = docSnap.data();
            const score = data.totalVotes > 0 ? (data.positiveVotes / data.totalVotes) * 100 : 0;
            return {
                positiveVotes: data.positiveVotes || 0,
                totalVotes: data.totalVotes || 0,
                score: parseFloat(score.toFixed(1)),
                userVote: userVoteType // This will be null if no user or user hasn't voted
            };
        } else {
            // No global votes yet for this question
            return { positiveVotes: 0, totalVotes: 0, score: 0, userVote: userVoteType };
        }
    } catch (error) {
        console.error("Firebase: Error getting question vote data:", error);
        // Return a default structure on error, including any userVote found
        return { positiveVotes: 0, totalVotes: 0, score: 0, userVote: userVoteType };
    }
}
```

=== main.js ===
```
// js/main.js
import * as ui from './ui.js';
import * as apiService from './apiService.js';
import * as quizService from './quizService.js';
import * as storageService from './storageService.js';
import * as firebaseService from './firebaseService.js'; // Import Firebase service
import { DATA_DIRECTORY, QUIZ_MANIFEST_ENDPOINT } from './config.js';

// HACK: Make quizService globally available for ui.js and dragAndDrop.js
// This should ideally be refactored with better dependency injection or event system.
window.quizServiceInstance = quizService;

document.addEventListener('DOMContentLoaded', () => {
    ui.initDOMReferences();

    async function initializeApp() {
        try {
            const quizFiles = await apiService.fetchQuizList(QUIZ_MANIFEST_ENDPOINT);
            ui.displayQuizList(quizFiles, handleQuizSelection);
        } catch (error) {
            console.error('Error initializing app:', error);
            ui.displayQuizListError(`Error loading quiz list: ${error.message}`);
        }
    }

    async function handleQuizSelection(fileName) {
        try {
            ui.showLoadingState();
            const quizData = await apiService.fetchQuizData(`${DATA_DIRECTORY}/${fileName}`);
            quizService.loadQuiz(quizData, fileName);

            const persistedState = storageService.loadQuizState(quizService.getCurrentQuizFile(), quizData.length);
            if (persistedState) {
                quizService.applyPersistedState(persistedState);
            }

            await renderCurrentQuizView(); // Make it async to await vote data
            ui.hideQuizList();
            ui.showQuizContainer();
        } catch (error) {
            console.error('Error loading quiz:', error);
            ui.displayQuizLoadError(error.message, fileName);
        }
    }

    async function renderCurrentQuizView() {
        const question = quizService.getCurrentQuestion();
        if (question) {
            const currentQIndex = quizService.getCurrentQuestionIndex();
            const currentFile = quizService.getCurrentQuizFile();
            let voteData = { positiveVotes: 0, totalVotes: 0, score: 0, userVote: null }; // Default
            if (currentFile && currentQIndex !== undefined) {
                 voteData = await firebaseService.getQuestionVoteData(currentFile, currentQIndex);
            }

            ui.displayQuestion(
                question,
                currentQIndex,
                quizService.getTotalQuestions(),
                quizService.getUserAnswerForCurrentQuestion(),
                quizService.isCurrentQuestionEvaluated(),
                voteData // Pass vote data
            );
            if (quizService.isCurrentQuestionEvaluated()) {
                ui.evaluateQuestionDisplay(question, quizService.getUserAnswerForCurrentQuestion());
            }
        } else {
            quizService.calculateFinalScore();
            ui.displayResults(quizService.getScore(), quizService.getTotalQuestions());
        }
        ui.updateButtonStates(
            quizService.getCurrentQuestionIndex(),
            quizService.getTotalQuestions(),
            quizService.areQuestionsLoaded()
        );
        ui.updateProgressPanel(
            quizService.getQuestions(),
            quizService.getCurrentQuestionIndex(),
            quizService.getUserAnswers(),
            quizService.getEvaluatedQuestions(),
            async (index) => { // Make this async for re-render
                quizService.setCurrentQuestionIndex(index);
                await renderCurrentQuizView();
            }
        );
    }

    ui.prevBtn.addEventListener('click', async () => {
        if (quizService.goToPreviousQuestion()) {
            await renderCurrentQuizView();
            storageService.saveQuizState(quizService.getFullState());
        }
    });

    ui.nextBtn.addEventListener('click', async () => {
        if (quizService.goToNextQuestion()) {
            await renderCurrentQuizView();
            storageService.saveQuizState(quizService.getFullState());
        }
    });

    ui.evaluateBtn.addEventListener('click', () => {
        if (!quizService.areQuestionsLoaded()) return;
        const question = quizService.getCurrentQuestion();
        const userAnswer = quizService.getUserAnswerForCurrentQuestion();
        quizService.markCurrentQuestionEvaluated();
        ui.evaluateQuestionDisplay(question, userAnswer);
        ui.disableEvaluateButton();
        ui.updateProgressPanel( // Re-call with current args to update progress panel
            quizService.getQuestions(),
            quizService.getCurrentQuestionIndex(),
            quizService.getUserAnswers(),
            quizService.getEvaluatedQuestions(),
            async (index) => { quizService.setCurrentQuestionIndex(index); await renderCurrentQuizView(); }
        );
        storageService.saveQuizState(quizService.getFullState());
    });

    ui.submitBtn.addEventListener('click', () => {
        quizService.calculateFinalScore();
        ui.displayResults(quizService.getScore(), quizService.getTotalQuestions());
        storageService.clearQuizState();
    });

    ui.resetBtn.addEventListener('click', async () => {
        quizService.resetCurrentQuestionAnswer();
        await renderCurrentQuizView();
        storageService.saveQuizState(quizService.getFullState());
    });

    ui.shuffleToggleBtn.addEventListener('click', async () => {
        const isShuffled = quizService.toggleShuffle();
        ui.updateShuffleButtonText(isShuffled);
        await renderCurrentQuizView();
        storageService.saveQuizState(quizService.getFullState());
    });

    document.addEventListener('answerChanged', (event) => {
        const { questionType, answer, questionIndex } = event.detail;
        quizService.saveAnswer(questionIndex, answer); // Removed questionType, saveAnswer doesn't use it
        ui.enableEvaluateButton();
        ui.clearEvaluationStylesForCurrentQuestion(); // Clear styles for the current question
        storageService.saveQuizState(quizService.getFullState());
        ui.updateProgressPanel( // Re-call with current args
            quizService.getQuestions(),
            quizService.getCurrentQuestionIndex(),
            quizService.getUserAnswers(),
            quizService.getEvaluatedQuestions(),
            async (index) => { quizService.setCurrentQuestionIndex(index); await renderCurrentQuizView(); }
        );
    });

    // Listen for vote events
    document.addEventListener('questionVoted', async (event) => {
        const { quizFile, questionIndex, voteType } = event.detail;
        if (!quizFile || questionIndex === undefined || !voteType) {
            console.error("Missing details in questionVoted event", event.detail);
            return;
        }
        const updatedVoteData = await firebaseService.recordVote(quizFile, questionIndex, voteType);
        if (updatedVoteData) {
            // Re-render the current question to display updated vote info
            // Ensure this only re-renders if the vote was for the *currently displayed* question
            if (quizFile === quizService.getCurrentQuizFile() && questionIndex === quizService.getCurrentQuestionIndex()) {
                 await renderCurrentQuizView(); // Only re-render if it's the current view
            }
        }
    });

    initializeApp();
});
```

=== questionManager.js ===
```
// js/questionManager.js
import * as multiChoice from './questionTypes/multiChoice.js';
import * as fillTheBlanks from './questionTypes/fillTheBlanks.js';
import * as dragAndDrop from './questionTypes/dragAndDrop.js';

const questionTypeModules = {
    'multi_choice': multiChoice,
    'fill_the_blanks': fillTheBlanks,
    'drag_n_drop': dragAndDrop,
};

export function renderQuestionContent(question, userAnswer, container, questionIndex, isEvaluated) {
    const handler = questionTypeModules[question.question_type];
    if (handler && handler.render) {
        return handler.render(question, userAnswer, container, questionIndex, isEvaluated);
    }
    return '<p>Unsupported question type.</p>';
}

// This function is called by UI when input changes to get the current answer
export function getAnswerFromDOM(questionType, questionContainer, questionIndex) {
    const handler = questionTypeModules[questionType];
    if (handler && handler.getAnswer) {
        return handler.getAnswer(questionContainer, questionIndex);
    }
    return null;
}

export function evaluateQuestionDisplay(question, userAnswer, questionContainer) {
    const handler = questionTypeModules[question.question_type];
    if (handler && handler.evaluateDisplay) {
        handler.evaluateDisplay(question, userAnswer, questionContainer);
    }
}

export function isAnswerCorrect(question, userAnswer) {
    const handler = questionTypeModules[question.question_type];
    if (handler && handler.isCorrect) {
        return handler.isCorrect(question, userAnswer);
    }
    return false;
}

// Attaches specific listeners for inputs within a question
// The callback will typically be a function in main.js that calls quizService.saveAnswer
export function attachInputListeners(question, questionContainer, questionIndex, answerChangedCallback) {
    const handler = questionTypeModules[question.question_type];
    if (handler && handler.addInputListeners) {
        handler.addInputListeners(questionContainer, questionIndex, (answerData) => {
            // The callback provided by main.js will save the answer via quizService
            // And also emit the 'answerChanged' event
            const event = new CustomEvent('answerChanged', {
                detail: {
                    questionType: question.question_type,
                    answer: answerData,
                    questionIndex: questionIndex
                }
            });
            document.dispatchEvent(event);
        });
    }
}
```

=== quizService.js ===
```
// js/quizService.js
import { shuffleArray } from './utils.js';
import * as questionManager from './questionManager.js';

let questions = [];
let originalQuestionsOrder = [];
let currentQuestionIndex = 0;
let userAnswers = [];
let evaluatedQuestions = [];
let score = 0;
let currentQuizFile = null;

export function loadQuiz(data, fileName) {
    originalQuestionsOrder = [...data];
    questions = [...data];
    currentQuizFile = fileName;
    resetQuizState(data.length);
}

export function applyPersistedState(state) {
    currentQuestionIndex = state.currentQuestionIndex;
    userAnswers = state.userAnswers;
    evaluatedQuestions = state.evaluatedQuestions || new Array(questions.length).fill(false);
    if (state.shuffledQuestions && state.originalQuestionsOrder) {
         questions = state.shuffledQuestions;
         originalQuestionsOrder = state.originalQuestionsOrder;
    }
}

function resetQuizState(numQuestions) {
    currentQuestionIndex = 0;
    userAnswers = new Array(numQuestions).fill(null);
    evaluatedQuestions = new Array(numQuestions).fill(false);
    score = 0;
}

export function getCurrentQuestion() { return questions[currentQuestionIndex]; }
export function getCurrentQuestionIndex() { return currentQuestionIndex; }
export function getTotalQuestions() { return questions.length; }
export function getUserAnswers() { return userAnswers; }
export function getEvaluatedQuestions() { return evaluatedQuestions; }
export function getQuestions() { return questions; }
export function getUserAnswerForCurrentQuestion() { return userAnswers[currentQuestionIndex]; }

export function saveAnswer(index, answerData) {
    if (index >= 0 && index < userAnswers.length) {
        userAnswers[index] = answerData;
        evaluatedQuestions[index] = false;
    }
}

export function goToNextQuestion() {
    if (currentQuestionIndex < questions.length - 1) {
        currentQuestionIndex++;
        return true;
    }
    return false;
}

export function goToPreviousQuestion() {
    if (currentQuestionIndex > 0) {
        currentQuestionIndex--;
        return true;
    }
    return false;
}
export function setCurrentQuestionIndex(index) {
    if (index >= 0 && index < questions.length) {
        currentQuestionIndex = index;
        return true;
    }
    return false;
}

export function toggleShuffle() {
    const shuffleButton = document.getElementById('shuffle-toggle-btn');
    if (shuffleButton && shuffleButton.textContent.includes('Unshuffle')) {
        questions = [...originalQuestionsOrder];
        resetQuizState(questions.length);
        return false;
    } else {
        questions = shuffleArray([...originalQuestionsOrder]);
        resetQuizState(questions.length);
        return true;
    }
}

export function resetCurrentQuestionAnswer() {
    if (questions[currentQuestionIndex]) {
        const questionType = questions[currentQuestionIndex].question_type;
        if (questionType === 'fill_the_blanks' || questionType === 'drag_n_drop') {
            userAnswers[currentQuestionIndex] = {};
        } else {
            userAnswers[currentQuestionIndex] = null;
        }
        evaluatedQuestions[currentQuestionIndex] = false;
    }
}

export function calculateFinalScore() {
    score = 0;
    questions.forEach((question, index) => {
        if (questionManager.isAnswerCorrect(question, userAnswers[index])) {
            score++;
        }
    });
}
export function getScore() { return score; }
export function markCurrentQuestionEvaluated() { evaluatedQuestions[currentQuestionIndex] = true; }
export function isCurrentQuestionEvaluated() { return evaluatedQuestions[currentQuestionIndex]; }
export function areQuestionsLoaded() { return questions && questions.length > 0; }
export function getCurrentQuizFile() { return currentQuizFile; }

export function getFullState() {
    return {
        quizFile: currentQuizFile,
        questionsLength: questions.length,
        currentQuestionIndex,
        userAnswers,
        evaluatedQuestions,
        timestamp: Date.now(),
    };
}
```

=== storageService.js ===
```
// js/storageService.js
import { STORAGE_KEY } from './config.js';

export function saveQuizState(state) {
    if (!state || !state.quizFile) return; // Basic check
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

export function loadQuizState(quizFile, expectedLength) {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return null;
    try {
        const state = JSON.parse(raw);
        // Validate state
        if (state.quizFile === quizFile && state.questionsLength === expectedLength &&
            Date.now() - (state.timestamp || 0) < (24 * 60 * 60 * 1000) // e.g. expire after 1 day
        ) {
            // Ensure userAnswers and evaluatedQuestions have correct length
            if (!Array.isArray(state.userAnswers) || state.userAnswers.length !== expectedLength) {
                state.userAnswers = new Array(expectedLength).fill(null);
            }
            if (!Array.isArray(state.evaluatedQuestions) || state.evaluatedQuestions.length !== expectedLength) {
                state.evaluatedQuestions = new Array(expectedLength).fill(false);
            }
            return state;
        }
    } catch (e) {
        console.error("Error loading quiz state from storage:", e);
    }
    clearQuizState(); // Clear invalid state
    return null;
}

export function clearQuizState() {
    localStorage.removeItem(STORAGE_KEY);
}
```

=== ui.js ===
```
// js/ui.js
import * as questionManager from './questionManager.js';
import { DATA_DIRECTORY } from './config.js';
import * as apiService from './apiService.js';

export let questionContainer, quizContainer, prevBtn, nextBtn, submitBtn, resultContainer,
           scoreElement, evaluateBtn, resetBtn, shuffleToggleBtn, quizListContainer,
           quizListElement, progressPanel, navigationControls;

export function initDOMReferences() {
    questionContainer = document.getElementById('question-container');
    quizContainer = document.getElementById('quiz-container');
    prevBtn = document.getElementById('prev-btn');
    nextBtn = document.getElementById('next-btn');
    submitBtn = document.getElementById('submit-btn');
    resultContainer = document.getElementById('result-container');
    scoreElement = document.getElementById('score');
    evaluateBtn = document.getElementById('evaluate-btn');
    resetBtn = document.getElementById('reset-btn');
    shuffleToggleBtn = document.getElementById('shuffle-toggle-btn');
    quizListContainer = document.getElementById('quiz-list-container');
    quizListElement = document.getElementById('quiz-list');
    progressPanel = document.getElementById('progress-panel');
    navigationControls = document.getElementById('navigation-controls');
}

export function displayQuizList(quizFileNames, onQuizSelectCallback) {
    quizListElement.innerHTML = '';
    if (!quizFileNames || quizFileNames.length === 0) {
        quizListElement.innerHTML = '<li>No quizzes available.</li>';
        quizContainer.style.display = 'none';
        quizListContainer.style.display = 'block';
        if (navigationControls) navigationControls.style.display = 'none';
        return;
    }

    const sortedQuizzes = [...quizFileNames].sort((a, b) => b.localeCompare(a));

    sortedQuizzes.forEach(fileName => {
        const listItem = document.createElement('li');
        const link = document.createElement('a');
        link.href = '#';
        link.dataset.fileName = fileName;
        link.addEventListener('click', (event) => {
            event.preventDefault();
            let target = event.target;
            while (target && !target.dataset.fileName && target !== document) {
                target = target.parentElement;
            }
            if (target && target.dataset.fileName) {
                onQuizSelectCallback(target.dataset.fileName);
            }
        });

        const card = document.createElement('div');
        card.className = 'quiz-card';

        apiService.fetchQuizSupervisionInfo(`${DATA_DIRECTORY}/${fileName}`)
            .then(supInfo => {
                let indicator = '';
                if (supInfo.generated === supInfo.total && supInfo.total > 0) {
                    indicator = '<span class="llm-indicator" title="This quiz set is entirely generated by an LLM">ü§ñ Generated</span>';
                } else if (supInfo.supervised === supInfo.total && supInfo.total > 0) {
                    indicator = '<span class="supervised-indicator" title="This quiz set is fully human supervised">‚úî Fully Supervised</span>';
                } else if (supInfo.supervised > 0) {
                    indicator = '<span class="partial-indicator" title="This quiz set already contains human supervised questions">‚ö†Ô∏è Partially Supervised</span>';
                } else if (supInfo.total > 0) {
                    indicator = '<span class="unsupervised-indicator" title="This quiz set generated from existing sources interpreted by an LLM and it was not yet supervised by a human">‚ùó Unsupervised</span>';
                }
                // Insert indicator after filename, before any potential future elements in card
                const filenameDiv = card.querySelector('.quiz-filename');
                if (filenameDiv && indicator) {
                    filenameDiv.insertAdjacentHTML('afterend', indicator);
                } else if (indicator) {
                    card.appendChild(document.createRange().createContextualFragment(indicator));
                }
            }).catch(err => console.warn(`Could not fetch supervision info for ${fileName}: ${err.message}`));

        let pretty = fileName.replace('.json','').replace(/_/g,' ');
        pretty = pretty.replace(/\b(zh|pzh|ppzh)\b/gi, m => m.toUpperCase());
        pretty = pretty.replace(/\b(\d{4})\b/g, '($1)');
        pretty = pretty.replace(/\b([a-z])/g, c => c.toUpperCase());

        const icon = document.createElement('div');
        icon.className = 'quiz-icon';
        icon.textContent = 'üìö';
        card.appendChild(icon);
        const title = document.createElement('div');
        title.className = 'quiz-title';
        title.textContent = pretty;
        card.appendChild(title);
        const fname = document.createElement('div');
        fname.className = 'quiz-filename';
        fname.textContent = fileName;
        card.appendChild(fname);

        link.appendChild(card);
        listItem.appendChild(link);
        quizListElement.appendChild(listItem);
    });

    quizContainer.style.display = 'none';
    quizListContainer.style.display = 'block';
    if (navigationControls) navigationControls.style.display = 'none';
}

export function displayQuestion(question, currentIndex, totalQuestions, userAnswer, isEvaluated, voteData) {
    if (!question) {
        questionContainer.innerHTML = '<p>No question to display.</p>';
        return;
    }
    clearEvaluationStylesForCurrentQuestion();

    let displaySupervisedIndicator = false;
    if (voteData && voteData.totalVotes > 10 && voteData.score > 70) {
        displaySupervisedIndicator = true;
    }

    let indicatorHtml = '';
    if (displaySupervisedIndicator || (question.supervised && question.supervised.trim().toLowerCase() === 'yes')) {
        indicatorHtml = `<span class="supervised-indicator" title="This question is considered trustworthy.">‚úî Supervised</span>`;
    } else if (question.supervised && question.supervised.trim().toLowerCase() === 'generated') {
        indicatorHtml = `<span class="llm-indicator" title="Generated by LLM">ü§ñ LLM generated</span>`;
    } else {
        indicatorHtml = `<span class="unsupervised-indicator" title="Not yet supervised or community reviewed">‚ùó Unsupervised</span>`;
    }

    let html = `<h3>Question ${currentIndex + 1} of ${totalQuestions} ${indicatorHtml}</h3>`;
    html += questionManager.renderQuestionContent(question, userAnswer, questionContainer, currentIndex, isEvaluated);
    questionContainer.innerHTML = html;

    const voteUiContainer = document.createElement('div');
    voteUiContainer.className = 'vote-ui-container';
    const scoreText = document.createElement('span');
    scoreText.className = 'vote-score-text';
    if (voteData && voteData.totalVotes > 0) {
        scoreText.textContent = `Trust: ${voteData.score}% (${voteData.positiveVotes}/${voteData.totalVotes} votes). `;
    } else {
        scoreText.textContent = "Trust: Be the first to rate! ";
    }
    voteUiContainer.appendChild(scoreText);

    const trustBtn = document.createElement('button');
    trustBtn.textContent = 'üëç Trustworthy';
    trustBtn.className = 'vote-btn trust';
    if (voteData && voteData.userVote === 'trust') trustBtn.classList.add('selected');
    trustBtn.onclick = () => {
        document.dispatchEvent(new CustomEvent('questionVoted', {
            detail: {
                quizFile: window.quizServiceInstance.getCurrentQuizFile(), // HACK
                questionIndex: currentIndex,
                voteType: 'trust'
            }
        }));
    };
    voteUiContainer.appendChild(trustBtn);

    const distrustBtn = document.createElement('button');
    distrustBtn.textContent = 'üëé Needs Review';
    distrustBtn.className = 'vote-btn distrust';
    if (voteData && voteData.userVote === 'distrust') distrustBtn.classList.add('selected');
    distrustBtn.onclick = () => {
        document.dispatchEvent(new CustomEvent('questionVoted', {
            detail: {
                quizFile: window.quizServiceInstance.getCurrentQuizFile(), // HACK
                questionIndex: currentIndex,
                voteType: 'distrust'
            }
        }));
    };
    voteUiContainer.appendChild(distrustBtn);

    const verificationInfoLabel = document.createElement('div');
    verificationInfoLabel.className = 'vote-verification-info';
    verificationInfoLabel.innerHTML = 'Questions with over 10 votes and 70% trustworthiness are considered Human Verified. Powered by Firebase üî•';
    voteUiContainer.appendChild(verificationInfoLabel);

    questionContainer.appendChild(voteUiContainer);

    questionManager.attachInputListeners(question, questionContainer, currentIndex);

    if (question.question_type === 'drag_n_drop') {
        // HACK: Ensure quizServiceInstance is available for D&D's internal population logic
        // if (!window.quizServiceInstance) console.warn("ui.displayQuestion: quizServiceInstance hack not set for D&D population");
        // The D&D module will use window.quizServiceInstance directly if needed
        questionManager.questionTypeModules.drag_n_drop.populateDropTargets(questionContainer, question, userAnswer);
        questionManager.questionTypeModules.drag_n_drop.updateDraggableVisibility(questionContainer);
    }

    evaluateBtn.disabled = isEvaluated;
}

export function updateButtonStates(currentIndex, totalQuestions, questionsLoaded) {
    if (!questionsLoaded) {
        if (navigationControls) navigationControls.style.display = 'none';
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        submitBtn.style.display = 'none';
        evaluateBtn.style.display = 'none';
        resetBtn.disabled = true;
        shuffleToggleBtn.disabled = true;
        return;
    }

    if (navigationControls) navigationControls.style.display = 'flex';
    const onLastQuestion = currentIndex === totalQuestions - 1;

    prevBtn.disabled = currentIndex === 0;
    nextBtn.disabled = onLastQuestion;
    submitBtn.style.display = onLastQuestion ? 'inline-block' : 'none';
    nextBtn.style.display = !onLastQuestion ? 'inline-block' : 'none';
    evaluateBtn.style.display = !onLastQuestion ? 'inline-block' : 'none';
    resetBtn.disabled = false;
    shuffleToggleBtn.disabled = false;
}

export function displayResults(score, totalQuestions) {
    questionContainer.style.display = 'none';
    if (navigationControls) navigationControls.style.display = 'none';
    resultContainer.style.display = 'block';
    scoreElement.textContent = `${score} out of ${totalQuestions}`;
    updateProgressPanel([], -1, [], [], () => {});
}

export function clearEvaluationStylesForCurrentQuestion() {
    const styledElements = questionContainer.querySelectorAll('.evaluation-correct, .evaluation-incorrect, .evaluation-missed');
    styledElements.forEach(el => {
        el.classList.remove('evaluation-correct', 'evaluation-incorrect', 'evaluation-missed');
         const label = el.querySelector('label');
        if (label) {
            label.classList.remove('evaluation-correct', 'evaluation-incorrect', 'evaluation-missed');
        }
    });
    const feedbackSpans = questionContainer.querySelectorAll('.inline-feedback');
    feedbackSpans.forEach(span => {
        span.textContent = '';
        span.className = 'inline-feedback';
    });
    const inputs = questionContainer.querySelectorAll('input[type="text"], .drop-target');
    inputs.forEach(input => {
        input.classList.remove('evaluation-correct', 'evaluation-incorrect', 'evaluation-missed');
    });
}

export function evaluateQuestionDisplay(question, userAnswer) {
    questionManager.evaluateQuestionDisplay(question, userAnswer, questionContainer);
}

export function updateProgressPanel(questions, currentIndex, userAnswers, evaluatedQuestions, onQuestionSelect) {
    if (!questions || questions.length === 0) {
        progressPanel.style.display = 'none';
        return;
    }
    progressPanel.style.display = 'block';
    let html = '<h3 style="margin-top:0;">Progress</h3><ul style="padding-left:0;list-style:none;">';

    questions.forEach((q, idx) => {
        let dotClass = 'dot-neutral';
        let statusTitle = 'Not answered / Not evaluated';

        if (evaluatedQuestions[idx]) {
            if (questionManager.isAnswerCorrect(q, userAnswers[idx])) {
                dotClass = 'dot-correct'; statusTitle = 'Correct';
            } else {
                dotClass = 'dot-incorrect'; statusTitle = 'Incorrect';
            }
        } else if (userAnswers[idx] !== null && userAnswers[idx] !== undefined && (typeof userAnswers[idx] !== 'object' || Object.keys(userAnswers[idx]).length > 0)) {
            dotClass = 'dot-answered'; statusTitle = 'Answered, not evaluated';
        }

        html += `<li style="margin-bottom:6px;cursor:pointer;${currentIndex === idx ? 'font-weight:bold;' : ''}" data-idx="${idx}" title="${statusTitle} - Go to question ${idx + 1}">
                    <span class="progress-dot ${dotClass}"></span>Question ${idx + 1}
                 </li>`;
    });
    html += '</ul>';
    progressPanel.innerHTML = html;

    progressPanel.querySelectorAll('li[data-idx]').forEach(li => {
        li.onclick = () => {
            const idx = parseInt(li.getAttribute('data-idx'));
            if (!isNaN(idx)) { onQuestionSelect(idx); }
        };
    });
    progressPanel.style.backgroundColor = '#fff';
    progressPanel.style.borderRadius = '8px';
    progressPanel.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
    progressPanel.style.padding = '16px';
    progressPanel.style.margin = '16px'; // You might want this outside #quiz-container in HTML
    // progressPanel.style.top = '10px'; // Position it if it's absolute/fixed
}

export function updateShuffleButtonText(isShuffled) { shuffleToggleBtn.textContent = isShuffled ? 'Unshuffle Questions' : 'Shuffle Questions'; }
export function displayQuizListError(message) { quizListElement.innerHTML = `<li style="color:red;">${message}</li>`; }
export function displayQuizLoadError(message, fileName) { questionContainer.innerHTML = `<p>Error loading quiz questions from ${fileName}. ${message}. Please check console.</p>`; }
export function showLoadingState() { questionContainer.innerHTML = '<p>Loading quiz...</p>'; }
export function hideQuizList() { quizListContainer.style.display = 'none'; }
export function showQuizContainer() { quizContainer.style.display = 'block'; }
export function disableEvaluateButton() { evaluateBtn.disabled = true; }
export function enableEvaluateButton() { evaluateBtn.disabled = false; }
```

=== updateSupervisionStatus.js ===
```
// updateSupervisionStatus.js (run this locally with Node.js)
// Make sure to `npm install firebase-admin` in your project root
const admin = require('firebase-admin');
const fs = require('fs').promises;
const path = require('path');

// IMPORTANT: Download your service account key from Firebase Console
// Project Settings -> Service accounts -> Generate new private key
// Save it as 'serviceAccountKey.json' in your project root (add to .gitignore!)
try {
    const serviceAccount = require('./serviceAccountKey.json');
    admin.initializeApp({
        credential: admin.credential.cert(serviceAccount)
    });
} catch (e) {
    console.error("Failed to initialize Firebase Admin SDK. Make sure 'serviceAccountKey.json' exists in the project root and is configured correctly.", e);
    process.exit(1);
}


const db = admin.firestore();
const DATA_DIR = path.join(__dirname, 'data');

async function updateLocalJsonFiles() {
    console.log("Fetching vote data from Firestore...");
    const snapshot = await db.collection('questionTrustVotes').get();

    if (snapshot.empty) {
        console.log('No vote data found in Firestore.');
        return;
    }

    const updatesByFile = {};

    snapshot.forEach(doc => {
        const voteData = doc.data();
        const { quizFile, qIndex, positiveVotes, totalVotes } = voteData;

        if (!quizFile || typeof qIndex !== 'number' || typeof totalVotes !== 'number' || typeof positiveVotes !== 'number') {
            console.warn(`Skipping invalid vote record (ID: ${doc.id}):`, voteData);
            return;
        }

        const score = totalVotes > 0 ? (positiveVotes / totalVotes) * 100 : 0;

        // Condition for marking as supervised
        if (score > 70 && totalVotes > 10) {
            if (!updatesByFile[quizFile]) {
                updatesByFile[quizFile] = [];
            }
            updatesByFile[quizFile].push({ index: qIndex, newStatus: "yes" });
            console.log(`Marking ${quizFile} - Question ${qIndex} as supervised (Score: ${score.toFixed(1)}%, Votes: ${totalVotes}).`);
        }
    });

    let filesUpdated = 0;
    for (const quizFileName in updatesByFile) {
        const filePath = path.join(DATA_DIR, quizFileName); // quizFileName should include .json
        try {
            // Check if file exists before trying to read
            await fs.access(filePath); // Throws error if not accessible
            let fileContent = await fs.readFile(filePath, 'utf8');
            let quizDataArray = JSON.parse(fileContent);

            if (!Array.isArray(quizDataArray)) {
                console.error(`Error: Content of ${quizFileName} is not an array.`);
                continue;
            }

            let fileModified = false;
            updatesByFile[quizFileName].forEach(update => {
                if (quizDataArray[update.index]) {
                    // Only update if the current status isn't already "yes" (or whatever newStatus is)
                    // to avoid unnecessary file writes if nothing changed.
                    if (quizDataArray[update.index].supervised !== update.newStatus) {
                        quizDataArray[update.index].supervised = update.newStatus;
                        fileModified = true;
                    }
                } else {
                    console.warn(`Question index ${update.index} not found in ${quizFileName}`);
                }
            });

            if (fileModified) {
                await fs.writeFile(filePath, JSON.stringify(quizDataArray, null, 2));
                console.log(`Updated ${quizFileName}`);
                filesUpdated++;
            } else {
                console.log(`No changes needed for ${quizFileName}.`);
            }

        } catch (error) {
            if (error.code === 'ENOENT') {
                console.error(`Error: File not found ${filePath}. Make sure quizFile names in Firestore match local data files.`);
            } else {
                console.error(`Error processing file ${quizFileName}:`, error);
            }
        }
    }
    if (filesUpdated > 0) {
        console.log(`${filesUpdated} quiz file(s) updated. Please review, commit, and push the changes.`);
    } else {
        console.log("No quiz files required updates based on current vote data.");
    }
    console.log("Supervision status update process complete.");
}

updateLocalJsonFiles().catch(error => {
    console.error("Unhandled error in updateLocalJsonFiles:", error);
});
```

=== utils.js ===
```
// js/utils.js
export function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}
```

=== dragAndDrop.js ===
```
// js/questionTypes/dragAndDrop.js

let currentDragData = null;

export function render(question, userAnswer, questionIndex, isEvaluated) {
    let dragDropText = question.text || "";
    const choices = question.choices || [];

    choices.forEach(choice => {
        if (choice && choice.identifier) {
            const placeholder = `[${choice.identifier}]`;
            const escapedIdentifier = choice.identifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            const placeholderRegex = new RegExp(`\\[${escapedIdentifier}\\]`, 'g');

            if (dragDropText.includes(placeholder)) {
                dragDropText = dragDropText.replace(placeholderRegex,
                    `<span class="drop-target" data-identifier="${choice.identifier}">
                         <span class="inline-feedback"></span>
                     </span>`
                );
            }
        }
    });

    let html = `<p>${dragDropText.replace(/\n/g, '<br>')}</p>`;
    html += '<div class="drag-options-container"><strong>Drag options:</strong><br><div id="drag-options">'; // Added container class
    choices.forEach(choice => {
        if (choice && choice.identifier && choice.label) {
            // Make ID unique per question instance if multiple D&D questions could somehow be on page (unlikely here)
            html += `<span class="draggable" draggable="${!isEvaluated}" id="drag-${questionIndex}-${choice.identifier}" data-identifier="${choice.identifier}">${choice.label}</span> `;
        }
    });
    html += '</div></div>';
    return html;
}

export function addInputListeners(questionContainer, questionIndex, onAnswerChangeCallback) {
    const draggables = questionContainer.querySelectorAll('.draggable[draggable="true"]'); // Only attach to active ones
    const dropTargets = questionContainer.querySelectorAll('.drop-target');

    draggables.forEach(el => {
        el.ondragstart = (ev) => dragStartHandler(ev);
    });

    dropTargets.forEach(el => {
        el.ondragover = dragOverHandler;
        el.ondragleave = dragLeaveHandler;
        el.ondrop = (ev) => dropHandler(ev, questionContainer, questionIndex, onAnswerChangeCallback);
    });

    // HACK: Accessing global quizService instance to get necessary data for initial population
    if (window.quizServiceInstance) {
        const questionData = window.quizServiceInstance.getCurrentQuestion();
        const userAnswer = window.quizServiceInstance.getUserAnswerForCurrentQuestion();
        if (questionData && questionData.question_type === 'drag_n_drop') { // Ensure it's for D&D
             populateDropTargets(questionContainer, questionData, userAnswer);
             updateDraggableVisibility(questionContainer);
        }
    } else {
        console.warn("D&D: quizServiceInstance not found on window for initial population.");
    }
}

function dragStartHandler(ev) {
    const draggableElement = ev.target.closest('.draggable[data-identifier]');
    if (!draggableElement || draggableElement.getAttribute('draggable') === 'false') {
        ev.preventDefault(); return;
    }
    currentDragData = {
        id: draggableElement.id,
        identifier: draggableElement.dataset.identifier
    };
    ev.dataTransfer.setData("text/plain", draggableElement.id);
    ev.dataTransfer.effectAllowed = "move";
}

function dragOverHandler(ev) {
    ev.preventDefault();
    const target = ev.target.closest('.drop-target');
    if (target) target.classList.add('highlight-drop');
}

function dragLeaveHandler(ev) {
    const target = ev.target.closest('.drop-target');
    if (target) target.classList.remove('highlight-drop');
}

function dropHandler(ev, questionContainer, questionIndex, onAnswerChangeCallback) {
    ev.preventDefault();
    const targetElement = ev.target.closest('.drop-target[data-identifier]');
    if (!targetElement || !currentDragData) {
        if (currentDragData) currentDragData = null;
        return;
    }

    targetElement.classList.remove('highlight-drop');
    const draggedChoiceIdentifier = currentDragData.identifier;
    // Find the original draggable element *within the current questionContainer* to get its text
    const draggedElementOriginal = questionContainer.querySelector(`#${currentDragData.id}`);


    const previouslyDroppedItemIdentifier = targetElement.getAttribute('data-dropped-item');
    if (previouslyDroppedItemIdentifier) {
        const existingDraggableInOptions = questionContainer.querySelector(`#drag-options .draggable[data-identifier="${previouslyDroppedItemIdentifier}"]`);
        if (existingDraggableInOptions) {
            existingDraggableInOptions.style.display = 'inline-block';
        }
        targetElement.textContent = '';
        const feedbackSpan = document.createElement('span');
        feedbackSpan.className = 'inline-feedback';
        targetElement.appendChild(feedbackSpan);
    }

    if (draggedElementOriginal) { // Ensure original draggable was found
        const labelTextNode = document.createTextNode(draggedElementOriginal.textContent);
        let feedbackSpan = targetElement.querySelector('.inline-feedback');
        if (!feedbackSpan) {
            feedbackSpan = document.createElement('span');
            feedbackSpan.className = 'inline-feedback';
            targetElement.appendChild(feedbackSpan);
        }
        targetElement.insertBefore(labelTextNode, feedbackSpan);
        targetElement.setAttribute('data-dropped-item', draggedChoiceIdentifier);
        draggedElementOriginal.style.display = 'none';
    } else {
        console.warn("D&D: Original draggable element not found for drop:", currentDragData.id);
    }


    currentDragData = null;

    const newAnswerMap = getAnswer(questionContainer, questionIndex);
    onAnswerChangeCallback(newAnswerMap); // This will trigger 'answerChanged' event in questionManager

    updateDraggableVisibility(questionContainer);
}

export function getAnswer(questionContainer, questionIndex) {
    const answers = {};
    const targets = questionContainer.querySelectorAll('.drop-target[data-identifier]');
    targets.forEach(target => {
        const targetId = target.dataset.identifier;
        const droppedItemId = target.getAttribute('data-dropped-item');
        if (targetId && droppedItemId) {
            answers[targetId] = droppedItemId;
        }
    });
    return answers;
}

export function evaluateDisplay(question, userAnswer, questionContainer) {
    const correctDropMapping = getCorrectDropMapping(question);
    const userAnswersMap = (userAnswer && typeof userAnswer === 'object') ? userAnswer : {};
    const choices = question.choices || [];

    questionContainer.querySelectorAll('.drop-target[data-identifier]').forEach(target => {
        const targetId = target.dataset.identifier;
        const feedbackSpan = target.querySelector('.inline-feedback');
        target.classList.remove('evaluation-correct', 'evaluation-incorrect', 'evaluation-missed');
        if(feedbackSpan) feedbackSpan.textContent = '';

        const droppedItemId = userAnswersMap[targetId];
        const correctItemIdForThisTarget = correctDropMapping[targetId];

        const correctChoiceDetails = choices.find(c => c.identifier === correctItemIdForThisTarget);
        const correctLabel = correctChoiceDetails ? correctChoiceDetails.label : '??';

        if (correctItemIdForThisTarget !== undefined) {
            if (droppedItemId && droppedItemId === correctItemIdForThisTarget) {
                target.classList.add('evaluation-correct');
                if (feedbackSpan) feedbackSpan.textContent = '‚úì';
            } else if (droppedItemId && droppedItemId !== correctItemIdForThisTarget) {
                target.classList.add('evaluation-incorrect');
                if (feedbackSpan) feedbackSpan.textContent = `‚úó (Should be: ${correctLabel})`;
            } else {
                target.classList.add('evaluation-missed');
                if (feedbackSpan) feedbackSpan.textContent = `Needed: ${correctLabel}`;
            }
        }
    });
    questionContainer.querySelectorAll('.draggable').forEach(d => d.setAttribute('draggable', 'false'));
}

export function isCorrect(question, userAnswer) {
    const correctMapping = getCorrectDropMapping(question);
    const targetIdsInQuestion = Object.keys(correctMapping);

    if (typeof userAnswer !== 'object' || userAnswer === null) {
        return targetIdsInQuestion.length === 0;
    }

    let correctCount = 0;
    let userAnswerKeysCount = 0;

    for (const targetId in userAnswer) {
        if (userAnswer.hasOwnProperty(targetId)) {
            userAnswerKeysCount++;
            if (correctMapping[targetId] && userAnswer[targetId] === correctMapping[targetId]) {
                correctCount++;
            }
        }
    }
    return correctCount === targetIdsInQuestion.length && userAnswerKeysCount === targetIdsInQuestion.length;
}

export function populateDropTargets(questionContainer, question, userAnswer) {
    const dropTargets = questionContainer.querySelectorAll('.drop-target[data-identifier]');
    const choices = question.choices || [];
    const savedUserAnswers = (userAnswer && typeof userAnswer === 'object') ? userAnswer : {};

    dropTargets.forEach(target => {
        const targetId = target.dataset.identifier;
        Array.from(target.childNodes).forEach(child => {
            if (child.nodeType === Node.TEXT_NODE) {
                target.removeChild(child);
            }
        });
        let feedbackSpan = target.querySelector('.inline-feedback');
        if (!feedbackSpan) {
            feedbackSpan = document.createElement('span');
            feedbackSpan.className = 'inline-feedback';
            target.appendChild(feedbackSpan);
        }
        feedbackSpan.textContent = '';
        target.removeAttribute('data-dropped-item');

        const droppedChoiceIdentifier = savedUserAnswers[targetId];
        if (droppedChoiceIdentifier) {
            const choiceData = choices.find(c => c.identifier === droppedChoiceIdentifier);
            if (choiceData && choiceData.label) {
                const labelTextNode = document.createTextNode(choiceData.label);
                target.insertBefore(labelTextNode, feedbackSpan);
                target.setAttribute('data-dropped-item', droppedChoiceIdentifier);
            }
        }
    });
}

export function updateDraggableVisibility(questionContainer) {
    const placedItemIdentifiers = new Set();
    questionContainer.querySelectorAll('.drop-target[data-dropped-item]').forEach(target => {
        placedItemIdentifiers.add(target.getAttribute('data-dropped-item'));
    });

    questionContainer.querySelectorAll('#drag-options .draggable[data-identifier]').forEach(draggable => {
        if (placedItemIdentifiers.has(draggable.dataset.identifier)) {
            draggable.style.display = 'none';
        } else {
            draggable.style.display = 'inline-block';
        }
    });
}

function getCorrectDropMapping(question) {
    const mapping = {};
    if (question && Array.isArray(question.choices)) {
        question.choices.forEach(choice => {
            if (choice && choice.identifier && question.text && question.text.includes(`[${choice.identifier}]`)) {
                mapping[choice.identifier] = choice.identifier;
            }
        });
    }
    return mapping;
}
```

=== fillTheBlanks.js ===
```
// js/questionTypes/fillTheBlanks.js
export function render(question, userAnswer, questionIndex, isEvaluated) {
    let questionText = question.text || "";
    const blanks = Array.isArray(question.blank) ? question.blank : (question.blank ? [question.blank] : []);
    const disabledAttr = isEvaluated ? 'disabled' : '';

    blanks.forEach((blank, i) => {
        if (blank && blank.identifier) {
            const savedValue = (userAnswer && typeof userAnswer === 'object' && userAnswer[blank.identifier]) ? userAnswer[blank.identifier] : '';
            const inputId = `q${questionIndex}_blank_${blank.identifier}_${i}`;
            const placeholderRegex = new RegExp(`\\[${blank.identifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\]`);

            questionText = questionText.replace(placeholderRegex,
                `<span class="input-wrapper">
                    <input type="text" id="${inputId}" data-identifier="${blank.identifier}" value="${savedValue}" placeholder="Fill blank..." ${disabledAttr}>
                    <span class="inline-feedback" id="feedback-${inputId}"></span>
                 </span>`
            );
        }
    });
    return `<p>${questionText.replace(/\n/g, '<br>')}</p>`;
}

export function addInputListeners(questionContainer, questionIndex, onAnswerChangeCallback) {
    const blankInputs = questionContainer.querySelectorAll('input[type="text"][data-identifier]');
    blankInputs.forEach(blank => {
        blank.addEventListener('input', () => {
            const currentAnswers = getAnswer(questionContainer, questionIndex);
            onAnswerChangeCallback(currentAnswers);

            blank.classList.remove('evaluation-correct', 'evaluation-incorrect', 'evaluation-missed');
            const feedbackSpan = questionContainer.querySelector(`#feedback-${blank.id}`);
            if (feedbackSpan) {
                feedbackSpan.textContent = '';
                feedbackSpan.className = 'inline-feedback';
            }
        });
    });
}

export function getAnswer(questionContainer, questionIndex) {
    const answers = {};
    const inputs = questionContainer.querySelectorAll('input[type="text"][data-identifier]');
    inputs.forEach(input => {
        const identifier = input.dataset.identifier;
        if (identifier) {
            answers[identifier] = input.value.trim();
        }
    });
    return answers;
}

export function evaluateDisplay(question, userAnswer, questionContainer) {
    const blanks = Array.isArray(question.blank) ? question.blank : (question.blank ? [question.blank] : []);
    const userAnswersMap = (userAnswer && typeof userAnswer === 'object') ? userAnswer : {};

    questionContainer.querySelectorAll('input[type="text"][data-identifier]').forEach(input => {
        const identifier = input.dataset.identifier;
        const blankDefinition = blanks.find(b => b.identifier === identifier);
        const correctAnswer = blankDefinition ? (blankDefinition.answer || "") : "";
        const userValue = userAnswersMap[identifier] || "";

        const feedbackSpan = questionContainer.querySelector(`#feedback-${input.id}`);
        input.classList.remove('evaluation-correct', 'evaluation-incorrect', 'evaluation-missed');
        if (feedbackSpan) feedbackSpan.textContent = '';

        if (userValue.toLowerCase() === correctAnswer.toLowerCase()) {
            input.classList.add('evaluation-correct');
            if (feedbackSpan) {
                feedbackSpan.textContent = '‚úì Correct!';
                feedbackSpan.className = 'inline-feedback feedback-correct';
            }
        } else {
            if (userValue === "") {
                input.classList.add('evaluation-missed');
                if (feedbackSpan) {
                    feedbackSpan.textContent = `‚úó Correct: ${correctAnswer}`;
                    feedbackSpan.className = 'inline-feedback feedback-missed';
                }
            } else {
                input.classList.add('evaluation-incorrect');
                if (feedbackSpan) {
                    feedbackSpan.textContent = `‚úó Incorrect. Correct: ${correctAnswer}`;
                    feedbackSpan.className = 'inline-feedback feedback-incorrect';
                }
            }
        }
        input.disabled = true;
    });
}

export function isCorrect(question, userAnswer) {
    const blanks = Array.isArray(question.blank) ? question.blank : (question.blank ? [question.blank] : []);
    if (blanks.length === 0) return true;
    if (typeof userAnswer !== 'object' || userAnswer === null) return false;

    for (const blankInfo of blanks) {
        if (!blankInfo || !blankInfo.identifier) {
             console.warn("Invalid blank data in question:", question);
             return false;
        }
        const correctAnswer = blankInfo.answer || "";
        const userAnswerForBlank = userAnswer[blankInfo.identifier] || "";
        if (userAnswerForBlank.toLowerCase() !== correctAnswer.toLowerCase()) {
            return false;
        }
    }
    return true;
}
```

=== multiChoice.js ===
```
// js/questionTypes/multiChoice.js
export function render(question, userAnswer, questionIndex, isEvaluated) {
    let html = `<p>${question.question_title}</p>`;
    html += '<ul style="list-style: none; padding: 0;">';
    if (question.options) {
        for (const key in question.options) {
            const isChecked = userAnswer && Array.isArray(userAnswer) && userAnswer.includes(key);
            const checkedAttribute = isChecked ? 'checked' : '';
            const inputType = Array.isArray(question.answer) && question.answer.length > 1 ? 'checkbox' : 'radio';
            const disabledAttr = isEvaluated ? 'disabled' : '';
            html += `
                <li data-option-key="${key}">
                    <label>
                        <input type="${inputType}" name="q${questionIndex}_option" value="${key}" ${checkedAttribute} ${disabledAttr}>
                        ${key.toUpperCase()}: ${question.options[key]}
                    </label>
                </li>`;
        }
    }
    html += '</ul>';
    return html;
}

export function addInputListeners(questionContainer, questionIndex, onAnswerChangeCallback) {
    const options = questionContainer.querySelectorAll(`input[name="q${questionIndex}_option"]`);
    options.forEach(option => {
        option.addEventListener('change', () => {
            const answer = getAnswer(questionContainer, questionIndex);
            onAnswerChangeCallback(answer);
        });
    });
}

export function getAnswer(questionContainer, questionIndex) {
    const selectedOptions = questionContainer.querySelectorAll(`input[name="q${questionIndex}_option"]:checked`);
    const firstInput = questionContainer.querySelector(`input[name="q${questionIndex}_option"]`);
    const isMultipleAnswer = firstInput && firstInput.type === 'checkbox';

    if (isMultipleAnswer) {
        return Array.from(selectedOptions).map(el => el.value);
    } else {
        return selectedOptions.length ? [selectedOptions[0].value] : [];
    }
}

export function evaluateDisplay(question, userAnswer, questionContainer) {
    const correctAnswerSet = new Set(Array.isArray(question.answer) ? question.answer : []);
    const optionsLi = questionContainer.querySelectorAll(`li[data-option-key]`);

    optionsLi.forEach(li => {
        li.classList.remove('evaluation-correct', 'evaluation-incorrect', 'evaluation-missed');
        const optionInput = li.querySelector('input');
        if (!optionInput) return;

        const optionValue = optionInput.value;
        const isChecked = optionInput.checked;
        const isCorrectOption = correctAnswerSet.has(optionValue);

        if (isChecked && isCorrectOption) {
            li.classList.add('evaluation-correct');
        } else if (isChecked && !isCorrectOption) {
            li.classList.add('evaluation-incorrect');
        } else if (!isChecked && isCorrectOption) {
            li.classList.add('evaluation-missed');
        }
        optionInput.disabled = true;
    });
}

export function isCorrect(question, userAnswer) {
    const correctAnswerMC = Array.isArray(question.answer) ? question.answer : [];
    const userAnswerMC = Array.isArray(userAnswer) ? userAnswer : [];

    if (userAnswerMC.length !== correctAnswerMC.length) return false;
    if (userAnswerMC.length === 0 && correctAnswerMC.length === 0) return true;

    const sortedUserAnswer = [...userAnswerMC].sort();
    const sortedCorrectAnswer = [...correctAnswerMC].sort();
    return JSON.stringify(sortedUserAnswer) === JSON.stringify(sortedCorrectAnswer);
}
```

