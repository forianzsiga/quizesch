// js/ui.js
import * as questionManager from './questionManager.js';
import { DATA_DIRECTORY } from './config.js'; // For image paths or other UI-related config
import * as apiService from './apiService.js'; // For quiz card supervision info

// DOM Element References - to be initialized
export let questionContainer, quizContainer, prevBtn, nextBtn, submitBtn, resultContainer,
           scoreElement, evaluateBtn, resetBtn, shuffleToggleBtn, quizListContainer,
           quizListElement, progressPanel, navigationControls;

export function initDOMReferences() {
    questionContainer = document.getElementById('question-container');
    quizContainer = document.getElementById('quiz-container');
    prevBtn = document.getElementById('prev-btn');
    nextBtn = document.getElementById('next-btn');
    submitBtn = document.getElementById('submit-btn');
    resultContainer = document.getElementById('result-container');
    scoreElement = document.getElementById('score');
    evaluateBtn = document.getElementById('evaluate-btn');
    resetBtn = document.getElementById('reset-btn');
    shuffleToggleBtn = document.getElementById('shuffle-toggle-btn');
    quizListContainer = document.getElementById('quiz-list-container');
    quizListElement = document.getElementById('quiz-list');
    progressPanel = document.getElementById('progress-panel');
    navigationControls = document.getElementById('navigation-controls');
}

export function displayQuizList(quizFileNames, onQuizSelectCallback) {
    quizListElement.innerHTML = '';
    if (!quizFileNames || quizFileNames.length === 0) {
        quizListElement.innerHTML = '<li>No quizzes available.</li>';
        quizContainer.style.display = 'none';
        quizListContainer.style.display = 'block';
        navigationControls.style.display = 'none';
        return;
    }

    const sortedQuizzes = [...quizFileNames].sort((a, b) => b.localeCompare(a));

    sortedQuizzes.forEach(fileName => {
        const listItem = document.createElement('li');
        const link = document.createElement('a');
        link.href = '#';
        link.dataset.fileName = fileName;
        link.addEventListener('click', (event) => {
            event.preventDefault();
            let target = event.target;
            while (target && !target.dataset.fileName && target !== document) {
                target = target.parentElement;
            }
            if (target && target.dataset.fileName) {
                onQuizSelectCallback(target.dataset.fileName);
            }
        });

        const card = document.createElement('div');
        card.className = 'quiz-card';
        // ... (rest of card creation logic from original, including supervision indicator fetch)
        // For supervision indicator:
        apiService.fetchQuizSupervisionInfo(`${DATA_DIRECTORY}/${fileName}`)
            .then(supInfo => {
                let indicator = '';
                if (supInfo.generated === supInfo.total && supInfo.total > 0) {
                    indicator = '<span class="llm-indicator" title="This quiz set is entirely generated by an LLM">ü§ñ Generated</span>';
                } else if (supInfo.supervised === supInfo.total && supInfo.total > 0) {
                    indicator = '<span class="supervised-indicator" title="This quiz set is fully human supervised">‚úî Fully Supervised</span>';
                } else if (supInfo.supervised > 0) {
                    indicator = '<span class="partial-indicator" title="This quiz set already contains human supervised questions">‚ö†Ô∏è Partially Supervised</span>';
                } else if (supInfo.total > 0) { // Check supInfo.total > 0 to avoid "Unsupervised" for empty quizzes
                    indicator = '<span class="unsupervised-indicator" title="This quiz set ... not yet supervised">‚ùó Unsupervised</span>';
                }
                card.appendChild(document.createRange().createContextualFragment(indicator));
            }).catch(err => console.warn(`Could not fetch supervision info for ${fileName}: ${err.message}`));


        // Prettify title
        let pretty = fileName.replace('.json','').replace(/_/g,' ');
        pretty = pretty.replace(/\b(zh|pzh|ppzh)\b/gi, m => m.toUpperCase());
        pretty = pretty.replace(/\b(\d{4})\b/g, '($1)');
        pretty = pretty.replace(/\b([a-z])/g, c => c.toUpperCase());

        const icon = document.createElement('div');
        icon.className = 'quiz-icon';
        icon.textContent = 'üìö';
        card.appendChild(icon);

        const title = document.createElement('div');
        title.className = 'quiz-title';
        title.textContent = pretty;
        card.appendChild(title);

        const fname = document.createElement('div');
        fname.className = 'quiz-filename';
        fname.textContent = fileName;
        card.appendChild(fname);


        link.appendChild(card);
        listItem.appendChild(link);
        quizListElement.appendChild(listItem);
    });

    quizContainer.style.display = 'none';
    quizListContainer.style.display = 'block';
    navigationControls.style.display = 'none';
}

export function displayQuestion(question, currentIndex, totalQuestions, userAnswer, isEvaluated) {
    if (!question) {
        questionContainer.innerHTML = '<p>No question to display.</p>';
        return;
    }
    clearEvaluationStylesForCurrentQuestion();

    let indicatorHtml = '';
    // ... (Supervision indicator logic for individual question from original displayQuestion)
    if ('supervised' in question && typeof question.supervised === 'string') {
        const sup = question.supervised.trim().toLowerCase();
        if (sup === 'yes') indicatorHtml = `<span class="supervised-indicator" title="Reviewed by human">‚úî supervised</span>`;
        else if (sup === 'generated') indicatorHtml = `<span class="llm-indicator" title="Generated by LLM">ü§ñ LLM generated</span>`;
        else indicatorHtml = `<span class="unsupervised-indicator" title="Not yet supervised">‚ùó unsupervised</span>`;
    } else {
        indicatorHtml = `<span class="unsupervised-indicator" title="Not yet supervised">‚ùó unsupervised</span>`;
    }


    let html = `<h3>Question ${currentIndex + 1} of ${totalQuestions} ${indicatorHtml}</h3>`;
    html += questionManager.renderQuestionContent(question, userAnswer, questionContainer, currentIndex, isEvaluated);
    questionContainer.innerHTML = html;

    // Attach listeners for the newly rendered question inputs
    // The callback will be handled in main.js to update quizService
    questionManager.attachInputListeners(question, questionContainer, currentIndex);

    if (question.question_type === 'drag_n_drop') {
        // D&D specific UI updates after render
        questionManager.questionTypeModules.drag_n_drop.populateDropTargets(questionContainer, question, userAnswer);
        questionManager.questionTypeModules.drag_n_drop.updateDraggableVisibility(questionContainer);
    }

    evaluateBtn.disabled = isEvaluated; // Disable if already evaluated
}


export function updateButtonStates(currentIndex, totalQuestions, questionsLoaded) {
    if (!questionsLoaded) {
        navigationControls.style.display = 'none';
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        submitBtn.style.display = 'none';
        evaluateBtn.style.display = 'none';
        resetBtn.disabled = true;
        shuffleToggleBtn.disabled = true;
        return;
    }

    navigationControls.style.display = 'flex';
    const onLastQuestion = currentIndex === totalQuestions - 1;

    prevBtn.disabled = currentIndex === 0;
    nextBtn.disabled = onLastQuestion;
    submitBtn.style.display = onLastQuestion ? 'inline-block' : 'none';
    nextBtn.style.display = !onLastQuestion ? 'inline-block' : 'none';
    evaluateBtn.style.display = !onLastQuestion ? 'inline-block' : 'none';
    resetBtn.disabled = false;
    shuffleToggleBtn.disabled = false;
}

export function displayResults(score, totalQuestions) {
    questionContainer.style.display = 'none';
    navigationControls.style.display = 'none';
    resultContainer.style.display = 'block';
    scoreElement.textContent = `${score} out of ${totalQuestions}`;
    updateProgressPanel([], -1, [], [], () => {}); // Clear progress panel or show final state
}

export function clearEvaluationStylesForCurrentQuestion() {
    const styledElements = questionContainer.querySelectorAll('.evaluation-correct, .evaluation-incorrect, .evaluation-missed');
    styledElements.forEach(el => {
        el.classList.remove('evaluation-correct', 'evaluation-incorrect', 'evaluation-missed');
         const label = el.querySelector('label'); // If it's a list item for multi-choice
        if (label) {
            label.classList.remove('evaluation-correct', 'evaluation-incorrect', 'evaluation-missed');
        }
    });
    // ... (clear styles for inputs, feedback spans, etc.)
    const feedbackSpans = questionContainer.querySelectorAll('.inline-feedback');
    feedbackSpans.forEach(span => {
        span.textContent = '';
        span.className = 'inline-feedback';
    });
    const inputs = questionContainer.querySelectorAll('input[type="text"], .drop-target');
    inputs.forEach(input => {
        input.classList.remove('evaluation-correct', 'evaluation-incorrect', 'evaluation-missed');
    });
}

export function evaluateQuestionDisplay(question, userAnswer) { // Renamed
    questionManager.evaluateQuestionDisplay(question, userAnswer, questionContainer);
}

export function updateProgressPanel(questions, currentIndex, userAnswers, evaluatedQuestions, onQuestionSelect) {
    if (!questions || questions.length === 0) {
        progressPanel.style.display = 'none';
        return;
    }
    progressPanel.style.display = 'block';
    let html = '<h3 style="margin-top:0;">Progress</h3><ul style="padding-left:0;list-style:none;">';

    questions.forEach((q, idx) => {
        let dotClass = 'dot-neutral'; // Default greyish
        let statusTitle = 'Not answered / Not evaluated';

        if (evaluatedQuestions[idx]) {
            if (questionManager.isAnswerCorrect(q, userAnswers[idx])) {
                dotClass = 'dot-correct'; // Green
                statusTitle = 'Correct';
            } else {
                dotClass = 'dot-incorrect'; // Red
                statusTitle = 'Incorrect';
            }
        } else if (userAnswers[idx] !== null && userAnswers[idx] !== undefined && (typeof userAnswers[idx] !== 'object' || Object.keys(userAnswers[idx]).length > 0)) {
             // Answered but not evaluated - maybe a blueish dot
            dotClass = 'dot-answered';
            statusTitle = 'Answered, not evaluated';
        }

        // Add CSS for .dot-neutral, .dot-correct, .dot-incorrect, .dot-answered in style.css
        html += `<li style="margin-bottom:6px;cursor:pointer;${currentIndex === idx ? 'font-weight:bold;' : ''}" data-idx="${idx}" title="${statusTitle} - Go to question ${idx + 1}">
                    <span class="progress-dot ${dotClass}"></span>Question ${idx + 1}
                 </li>`;
    });
    html += '</ul>';
    progressPanel.innerHTML = html;

    progressPanel.querySelectorAll('li[data-idx]').forEach(li => {
        li.onclick = () => {
            const idx = parseInt(li.getAttribute('data-idx'));
            if (!isNaN(idx)) {
                onQuestionSelect(idx);
            }
        };
    });
    // Apply existing panel styles if not in CSS
    progressPanel.style.backgroundColor = '#fff';
    progressPanel.style.borderRadius = '8px';
    // ... etc.
}
export function updateShuffleButtonText(isShuffled) {
    shuffleToggleBtn.textContent = isShuffled ? 'Unshuffle Questions' : 'Shuffle Questions';
}
export function displayQuizListError(message) {
    quizListElement.innerHTML = `<li>${message}</li>`;
    quizListElement.style.color = 'red';
    // ... hide other elements
}
export function displayQuizLoadError(message, fileName) {
    questionContainer.innerHTML = `<p>Error loading quiz questions from ${fileName}. ${message}. Please check console.</p>`;
    // ... hide/show relevant containers
}
export function showLoadingState() {
    questionContainer.innerHTML = '<p>Loading quiz...</p>';
}
export function hideQuizList() { quizListContainer.style.display = 'none'; }
export function showQuizContainer() { quizContainer.style.display = 'block'; }
export function disableEvaluateButton() { evaluateBtn.disabled = true; }
export function enableEvaluateButton() { evaluateBtn.disabled = false; }