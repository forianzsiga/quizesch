// js/ui.js
import * as questionManager from './questionManager.js';
import { DATA_DIRECTORY } from './config.js';
import * as apiService from './apiService.js';

export let questionContainer, quizContainer, prevBtn, nextBtn, submitBtn, resultContainer,
           scoreElement, evaluateBtn, resetBtn, shuffleToggleBtn, quizListContainer,
           quizListElement, progressPanel, navigationControls;

export function initDOMReferences() {
    questionContainer = document.getElementById('question-container');
    quizContainer = document.getElementById('quiz-container');
    prevBtn = document.getElementById('prev-btn');
    nextBtn = document.getElementById('next-btn');
    submitBtn = document.getElementById('submit-btn');
    resultContainer = document.getElementById('result-container');
    scoreElement = document.getElementById('score');
    evaluateBtn = document.getElementById('evaluate-btn');
    resetBtn = document.getElementById('reset-btn');
    shuffleToggleBtn = document.getElementById('shuffle-toggle-btn');
    quizListContainer = document.getElementById('quiz-list-container');
    quizListElement = document.getElementById('quiz-list');
    progressPanel = document.getElementById('progress-panel');
    navigationControls = document.getElementById('navigation-controls');
}

export function displayQuizList(quizFileNames, onQuizSelectCallback) {
    quizListElement.innerHTML = '';
    if (!quizFileNames || quizFileNames.length === 0) {
        quizListElement.innerHTML = '<li>No quizzes available.</li>';
        quizContainer.style.display = 'none';
        quizListContainer.style.display = 'block';
        if (navigationControls) navigationControls.style.display = 'none';
        return;
    }

    const sortedQuizzes = [...quizFileNames].sort((a, b) => b.localeCompare(a));

    sortedQuizzes.forEach(fileName => {
        const listItem = document.createElement('li');
        const link = document.createElement('a');
        link.href = '#';
        link.dataset.fileName = fileName;
        link.addEventListener('click', (event) => {
            event.preventDefault();
            let target = event.target;
            while (target && !target.dataset.fileName && target !== document) {
                target = target.parentElement;
            }
            if (target && target.dataset.fileName) {
                onQuizSelectCallback(target.dataset.fileName);
            }
        });

        const card = document.createElement('div');
        card.className = 'quiz-card';

        apiService.fetchQuizSupervisionInfo(`${DATA_DIRECTORY}/${fileName}`)
            .then(supInfo => {
                let indicator = '';
                if (supInfo.generated === supInfo.total && supInfo.total > 0) {
                    indicator = '<span class="llm-indicator" title="This quiz set is entirely generated by an LLM">ü§ñ Generated</span>';
                } else if (supInfo.supervised === supInfo.total && supInfo.total > 0) {
                    indicator = '<span class="supervised-indicator" title="This quiz set is fully human supervised">‚úî Fully Supervised</span>';
                } else if (supInfo.supervised > 0) {
                    indicator = '<span class="partial-indicator" title="This quiz set already contains human supervised questions">‚ö†Ô∏è Partially Supervised</span>';
                } else if (supInfo.total > 0) {
                    indicator = '<span class="unsupervised-indicator" title="This quiz set generated from existing sources interpreted by an LLM and it was not yet supervised by a human">‚ùó Unsupervised</span>';
                }
                // Insert indicator after filename, before any potential future elements in card
                const filenameDiv = card.querySelector('.quiz-filename');
                if (filenameDiv && indicator) {
                    filenameDiv.insertAdjacentHTML('afterend', indicator);
                } else if (indicator) {
                    card.appendChild(document.createRange().createContextualFragment(indicator));
                }
            }).catch(err => console.warn(`Could not fetch supervision info for ${fileName}: ${err.message}`));

        let pretty = fileName.replace('.json','').replace(/_/g,' ');
        pretty = pretty.replace(/\b(zh|pzh|ppzh)\b/gi, m => m.toUpperCase());
        pretty = pretty.replace(/\b(\d{4})\b/g, '($1)');
        pretty = pretty.replace(/\b([a-z])/g, c => c.toUpperCase());

        const icon = document.createElement('div');
        icon.className = 'quiz-icon';
        icon.textContent = 'üìö';
        card.appendChild(icon);
        const title = document.createElement('div');
        title.className = 'quiz-title';
        title.textContent = pretty;
        card.appendChild(title);
        const fname = document.createElement('div');
        fname.className = 'quiz-filename';
        fname.textContent = fileName;
        card.appendChild(fname);

        link.appendChild(card);
        listItem.appendChild(link);
        quizListElement.appendChild(listItem);
    });

    quizContainer.style.display = 'none';
    quizListContainer.style.display = 'block';
    if (navigationControls) navigationControls.style.display = 'none';
}

export function displayQuestion(question, currentIndex, totalQuestions, userAnswer, isEvaluated, voteData) {
    if (!question) {
        questionContainer.innerHTML = '<p>No question to display.</p>';
        return;
    }
    clearEvaluationStylesForCurrentQuestion();

    let displaySupervisedIndicator = false;
    if (voteData && voteData.totalVotes > 10 && voteData.score > 70) {
        displaySupervisedIndicator = true;
    }

    let indicatorHtml = '';
    if (displaySupervisedIndicator || (question.supervised && question.supervised.trim().toLowerCase() === 'yes')) {
        indicatorHtml = `<span class="supervised-indicator" title="This question is considered trustworthy.">‚úî Supervised</span>`;
    } else if (question.supervised && question.supervised.trim().toLowerCase() === 'generated') {
        indicatorHtml = `<span class="llm-indicator" title="Generated by LLM">ü§ñ LLM generated</span>`;
    } else {
        indicatorHtml = `<span class="unsupervised-indicator" title="Not yet supervised or community reviewed">‚ùó Unsupervised</span>`;
    }

    let html = `<h3>Question ${currentIndex + 1} of ${totalQuestions} ${indicatorHtml}</h3>`;
    html += questionManager.renderQuestionContent(question, userAnswer, questionContainer, currentIndex, isEvaluated);
    questionContainer.innerHTML = html;

    const voteUiContainer = document.createElement('div');
    voteUiContainer.className = 'vote-ui-container';
    const scoreText = document.createElement('span');
    scoreText.className = 'vote-score-text';
    if (voteData && voteData.totalVotes > 0) {
        scoreText.textContent = `Trust: ${voteData.score}% (${voteData.positiveVotes}/${voteData.totalVotes} votes). `;
    } else {
        scoreText.textContent = "Trust: Be the first to rate! ";
    }
    voteUiContainer.appendChild(scoreText);

    const trustBtn = document.createElement('button');
    trustBtn.textContent = 'üëç Trustworthy';
    trustBtn.className = 'vote-btn trust';
    if (voteData && voteData.userVote === 'trust') trustBtn.classList.add('selected');
    trustBtn.onclick = () => {
        document.dispatchEvent(new CustomEvent('questionVoted', {
            detail: {
                quizFile: window.quizServiceInstance.getCurrentQuizFile(), // HACK
                questionIndex: currentIndex,
                voteType: 'trust'
            }
        }));
    };
    voteUiContainer.appendChild(trustBtn);

    const distrustBtn = document.createElement('button');
    distrustBtn.textContent = 'üëé Needs Review';
    distrustBtn.className = 'vote-btn distrust';
    if (voteData && voteData.userVote === 'distrust') distrustBtn.classList.add('selected');
    distrustBtn.onclick = () => {
        document.dispatchEvent(new CustomEvent('questionVoted', {
            detail: {
                quizFile: window.quizServiceInstance.getCurrentQuizFile(), // HACK
                questionIndex: currentIndex,
                voteType: 'distrust'
            }
        }));
    };
    voteUiContainer.appendChild(distrustBtn);

    const verificationInfoLabel = document.createElement('div');
    verificationInfoLabel.className = 'vote-verification-info';
    verificationInfoLabel.innerHTML = 'Questions with over 10 votes and 70% trustworthiness are considered Human Verified. Powered by Firebase üî•';
    voteUiContainer.appendChild(verificationInfoLabel);

    questionContainer.appendChild(voteUiContainer);

    questionManager.attachInputListeners(question, questionContainer, currentIndex);

    evaluateBtn.disabled = isEvaluated;
}

export function updateButtonStates(currentIndex, totalQuestions, questionsLoaded) {
    if (!questionsLoaded) {
        if (navigationControls) navigationControls.style.display = 'none';
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        submitBtn.style.display = 'none';
        evaluateBtn.style.display = 'none';
        resetBtn.disabled = true;
        shuffleToggleBtn.disabled = true;
        return;
    }

    if (navigationControls) navigationControls.style.display = 'flex';
    const onLastQuestion = currentIndex === totalQuestions - 1;

    prevBtn.disabled = currentIndex === 0;
    nextBtn.disabled = onLastQuestion;
    submitBtn.style.display = onLastQuestion ? 'inline-block' : 'none';
    nextBtn.style.display = !onLastQuestion ? 'inline-block' : 'none';
    evaluateBtn.style.display = !onLastQuestion ? 'inline-block' : 'none';
    resetBtn.disabled = false;
    shuffleToggleBtn.disabled = false;
}

export function displayResults(score, totalQuestions) {
    questionContainer.style.display = 'none';
    if (navigationControls) navigationControls.style.display = 'none';
    resultContainer.style.display = 'block';
    scoreElement.textContent = `${score} out of ${totalQuestions}`;
    updateProgressPanel([], -1, [], [], () => {});
}

export function clearEvaluationStylesForCurrentQuestion() {
    const styledElements = questionContainer.querySelectorAll('.evaluation-correct, .evaluation-incorrect, .evaluation-missed');
    styledElements.forEach(el => {
        el.classList.remove('evaluation-correct', 'evaluation-incorrect', 'evaluation-missed');
         const label = el.querySelector('label');
        if (label) {
            label.classList.remove('evaluation-correct', 'evaluation-incorrect', 'evaluation-missed');
        }
    });
    const feedbackSpans = questionContainer.querySelectorAll('.inline-feedback');
    feedbackSpans.forEach(span => {
        span.textContent = '';
        span.className = 'inline-feedback';
    });
    const inputs = questionContainer.querySelectorAll('input[type="text"], .drop-target');
    inputs.forEach(input => {
        input.classList.remove('evaluation-correct', 'evaluation-incorrect', 'evaluation-missed');
    });
}

export function evaluateQuestionDisplay(question, userAnswer) {
    questionManager.evaluateQuestionDisplay(question, userAnswer, questionContainer);
}

export function updateProgressPanel(questions, currentIndex, userAnswers, evaluatedQuestions, onQuestionSelect) {
    if (!questions || questions.length === 0) {
        progressPanel.style.display = 'none';
        return;
    }
    progressPanel.style.display = 'block';
    let html = '<h3 style="margin-top:0;">Progress</h3><ul style="padding-left:0;list-style:none;">';

    questions.forEach((q, idx) => {
        let dotClass = 'dot-neutral';
        let statusTitle = 'Not answered / Not evaluated';

        if (evaluatedQuestions[idx]) {
            if (questionManager.isAnswerCorrect(q, userAnswers[idx])) {
                dotClass = 'dot-correct'; statusTitle = 'Correct';
            } else {
                dotClass = 'dot-incorrect'; statusTitle = 'Incorrect';
            }
        } else if (userAnswers[idx] !== null && userAnswers[idx] !== undefined && (typeof userAnswers[idx] !== 'object' || Object.keys(userAnswers[idx]).length > 0)) {
            dotClass = 'dot-answered'; statusTitle = 'Answered, not evaluated';
        }

        html += `<li style="margin-bottom:6px;cursor:pointer;${currentIndex === idx ? 'font-weight:bold;' : ''}" data-idx="${idx}" title="${statusTitle} - Go to question ${idx + 1}">
                    <span class="progress-dot ${dotClass}"></span>Question ${idx + 1}
                 </li>`;
    });
    html += '</ul>';
    progressPanel.innerHTML = html;

    progressPanel.querySelectorAll('li[data-idx]').forEach(li => {
        li.onclick = () => {
            const idx = parseInt(li.getAttribute('data-idx'));
            if (!isNaN(idx)) { onQuestionSelect(idx); }
        };
    });
    progressPanel.style.backgroundColor = '#fff';
    progressPanel.style.borderRadius = '8px';
    progressPanel.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
    progressPanel.style.padding = '16px';
    progressPanel.style.margin = '16px'; // You might want this outside #quiz-container in HTML
    // progressPanel.style.top = '10px'; // Position it if it's absolute/fixed
}

export function updateVoteUIDisplay(voteData) {
    const voteUiContainer = questionContainer.querySelector('.vote-ui-container');
    if (!voteUiContainer) return; // Should exist if displayQuestion was called

    const scoreText = voteUiContainer.querySelector('.vote-score-text');
    const trustBtn = voteUiContainer.querySelector('.vote-btn.trust');
    const distrustBtn = voteUiContainer.querySelector('.vote-btn.distrust');

    if (scoreText) {
        if (voteData && voteData.totalVotes > 0) {
            scoreText.textContent = `Trust: ${voteData.score}% (${voteData.positiveVotes}/${voteData.totalVotes} votes). `;
        } else {
            scoreText.textContent = "Trust: Be the first to rate! ";
        }
    }
    if (trustBtn) {
        trustBtn.classList.toggle('selected', voteData && voteData.userVote === 'trust');
    }
    if (distrustBtn) {
        distrustBtn.classList.toggle('selected', voteData && voteData.userVote === 'distrust');
    }
}


export function updateShuffleButtonText(isShuffled) { shuffleToggleBtn.textContent = isShuffled ? 'Unshuffle Questions' : 'Shuffle Questions'; }
export function displayQuizListError(message) { quizListElement.innerHTML = `<li style="color:red;">${message}</li>`; }
export function displayQuizLoadError(message, fileName) { questionContainer.innerHTML = `<p>Error loading quiz questions from ${fileName}. ${message}. Please check console.</p>`; }
export function showLoadingState() { questionContainer.innerHTML = '<p>Loading quiz...</p>'; }
export function hideQuizList() { quizListContainer.style.display = 'none'; }
export function showQuizContainer() { quizContainer.style.display = 'block'; }
export function disableEvaluateButton() { evaluateBtn.disabled = true; }
export function enableEvaluateButton() { evaluateBtn.disabled = false; }